// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using Modio.API.SchemaDefinitions;
using Modio.Errors;
using Modio.Extensions;

namespace Modio.API
{
    public static partial class ModioAPI
    {
        public static partial class Me
        {
            /// <summary>
            /// <p>Get all modfiles the _authenticated user_ uploaded. Successful request will return an array of [Modfile Objects](#get-modfiles-2). We recommended reading the [filtering documentation](#filtering) to return only the records you want.</p>
            /// <p>__NOTE:__ If the [game](#edit-game) requires mod downloads to be initiated via the API, the `binary_url` returned will contain a verification hash. This hash must be supplied to get the modfile, and will expire after a certain period of time. Saving and reusing the `binary_url` won't work in this situation given it's dynamic nature.</p>
            /// </summary>
            /// <param name="filter">Filter to apply to the request.</param>
            internal static async Task<(Error error, JToken modfileObjects)> GetUserModfilesAsJToken(
            GetUserModfilesFilter filter
            ) {
                if (!IsInitialized()) return (new Error(ErrorCode.API_NOT_INITIALIZED), null);

                using var request = ModioAPIRequest.New($"/me/files", ModioAPIRequestMethod.Get);

                request.Options.AddFilterParameters(filter);
                request.Options.RequireAuthentication();

                return await _apiInterface.GetJson(request);
            }

            /// <summary>
            /// <p>Get all modfiles the _authenticated user_ uploaded. Successful request will return an array of [Modfile Objects](#get-modfiles-2). We recommended reading the [filtering documentation](#filtering) to return only the records you want.</p>
            /// <p>__NOTE:__ If the [game](#edit-game) requires mod downloads to be initiated via the API, the `binary_url` returned will contain a verification hash. This hash must be supplied to get the modfile, and will expire after a certain period of time. Saving and reusing the `binary_url` won't work in this situation given it's dynamic nature.</p>
            /// </summary>
            /// <param name="filter">Filter to apply to the request.</param>
            internal static async Task<(Error error, Pagination<ModfileObject[]>? modfileObjects)> GetUserModfiles(
            GetUserModfilesFilter filter
            ) {
                if (!IsInitialized()) return (new Error(ErrorCode.API_NOT_INITIALIZED), null);

                using var request = ModioAPIRequest.New($"/me/files", ModioAPIRequestMethod.Get);

                request.Options.AddFilterParameters(filter);
                request.Options.RequireAuthentication();

                return await _apiInterface.GetJson<Pagination<ModfileObject[]>>(request);
            }
#region Filter
        
            /// <summary>Constructs a filter built for this request type.</summary>
            /// <param name="pageIndex">The search will skip <c>pageIndex * pageSize</c> results and return (up to) the following <see cref="pageSize"/> results.</param>
            /// <param name="pageSize">Limit the number of results returned (100 max).<p>Use <see cref="SetPageIndex"/> to skip results and return later results.</p></param>
            public static GetUserModfilesFilter FilterGetUserModfiles(
                int pageIndex = 0,
                int pageSize = 100
            ) 
            => new GetUserModfilesFilter(
                pageIndex, 
                pageSize
            );
            
            /// <summary>
            /// Filter for GetUserModfiles, see <see cref="Me.FilterGetUserModfiles"/>
            /// to construct this filter <br/>
            /// Filtering options:<br/>
            /// </summary>
            public class GetUserModfilesFilter : SearchFilter<GetUserModfilesFilter>
            {
                internal GetUserModfilesFilter(
                    int pageIndex,
                    int pageSize
                ) : base(pageIndex, pageSize) 
                {
                }

                /// <param name="id">Unique id of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Id(long id, Filtering condition = Filtering.None)
                {
                    Parameters[$"id{condition.ClearText()}"] = id;
                    return this;
                }

                /// <param name="id">An ICollection of Unique id of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Id(ICollection<long> id, Filtering condition = Filtering.None)
                {
                    Parameters[$"id{condition.ClearText()}"] = id;
                    return this;
                }
                

                /// <param name="modId">Unique id of the mod.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter ModId(long modId, Filtering condition = Filtering.None)
                {
                    Parameters[$"mod_id{condition.ClearText()}"] = modId;
                    return this;
                }

                /// <param name="modId">An ICollection of Unique id of the mod.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter ModId(ICollection<long> modId, Filtering condition = Filtering.None)
                {
                    Parameters[$"mod_id{condition.ClearText()}"] = modId;
                    return this;
                }
                

                /// <param name="dateAdded">Unix timestamp of date file was added.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter DateAdded(long dateAdded, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_added{condition.ClearText()}"] = dateAdded.RoundTimestampToHour();
                    return this;
                }

                /// <param name="dateAdded">An ICollection of Unix timestamp of date file was added.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter DateAdded(ICollection<long> dateAdded, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_added{condition.ClearText()}"] = dateAdded.RoundTimestampsToHour();
                    return this;
                }
                

                /// <param name="dateScanned">Unix timestamp of date file was virus scanned.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter DateScanned(long dateScanned, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_scanned{condition.ClearText()}"] = dateScanned.RoundTimestampToHour();
                    return this;
                }

                /// <param name="dateScanned">An ICollection of Unix timestamp of date file was virus scanned.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter DateScanned(ICollection<long> dateScanned, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_scanned{condition.ClearText()}"] = dateScanned.RoundTimestampsToHour();
                    return this;
                }
                

                /// <param name="virusStatus">Current virus scan status of the file. For newly added files that have yet to be scanned this field will change frequently until a scan is complete:<br/><br/>__0__ = Not scanned<br/>__1__ = Scan complete<br/>__2__ = In progress<br/>__3__ = Too large to scan<br/>__4__ = File not found<br/>__5__ = Error Scanning</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter VirusStatus(long virusStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_status{condition.ClearText()}"] = virusStatus;
                    return this;
                }

                /// <param name="virusStatus">An ICollection of Current virus scan status of the file. For newly added files that have yet to be scanned this field will change frequently until a scan is complete:<br/><br/>__0__ = Not scanned<br/>__1__ = Scan complete<br/>__2__ = In progress<br/>__3__ = Too large to scan<br/>__4__ = File not found<br/>__5__ = Error Scanning</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter VirusStatus(ICollection<long> virusStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_status{condition.ClearText()}"] = virusStatus;
                    return this;
                }
                

                /// <param name="virusPositive">Was a virus detected:<br/><br/>__0__ = No threats detected<br/>__1__ = Flagged as malicious<br/>__2__ = Flagged as containing potentially harmful files (i.e. EXEs)</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter VirusPositive(long virusPositive, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_positive{condition.ClearText()}"] = virusPositive;
                    return this;
                }

                /// <param name="virusPositive">An ICollection of Was a virus detected:<br/><br/>__0__ = No threats detected<br/>__1__ = Flagged as malicious<br/>__2__ = Flagged as containing potentially harmful files (i.e. EXEs)</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter VirusPositive(ICollection<long> virusPositive, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_positive{condition.ClearText()}"] = virusPositive;
                    return this;
                }
                

                /// <param name="filesize">Size of the file in bytes.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Filesize(long filesize, Filtering condition = Filtering.None)
                {
                    Parameters[$"filesize{condition.ClearText()}"] = filesize;
                    return this;
                }

                /// <param name="filesize">An ICollection of Size of the file in bytes.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Filesize(ICollection<long> filesize, Filtering condition = Filtering.None)
                {
                    Parameters[$"filesize{condition.ClearText()}"] = filesize;
                    return this;
                }
                

                /// <param name="filehash">MD5 hash of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Filehash(string filehash, Filtering condition = Filtering.None)
                {
                    Parameters[$"filehash{condition.ClearText()}"] = filehash;
                    return this;
                }

                /// <param name="filehash">An ICollection of MD5 hash of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Filehash(ICollection<string> filehash, Filtering condition = Filtering.None)
                {
                    Parameters[$"filehash{condition.ClearText()}"] = filehash;
                    return this;
                }
                

                /// <param name="filename">Filename including extension.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Filename(string filename, Filtering condition = Filtering.None)
                {
                    Parameters[$"filename{condition.ClearText()}"] = filename;
                    return this;
                }

                /// <param name="filename">An ICollection of Filename including extension.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Filename(ICollection<string> filename, Filtering condition = Filtering.None)
                {
                    Parameters[$"filename{condition.ClearText()}"] = filename;
                    return this;
                }
                

                /// <param name="version">Release version this file represents.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Version(string version, Filtering condition = Filtering.None)
                {
                    Parameters[$"version{condition.ClearText()}"] = version;
                    return this;
                }

                /// <param name="version">An ICollection of Release version this file represents.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Version(ICollection<string> version, Filtering condition = Filtering.None)
                {
                    Parameters[$"version{condition.ClearText()}"] = version;
                    return this;
                }
                

                /// <param name="changelog">Changelog for the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Changelog(string changelog, Filtering condition = Filtering.None)
                {
                    Parameters[$"changelog{condition.ClearText()}"] = changelog;
                    return this;
                }

                /// <param name="changelog">An ICollection of Changelog for the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter Changelog(ICollection<string> changelog, Filtering condition = Filtering.None)
                {
                    Parameters[$"changelog{condition.ClearText()}"] = changelog;
                    return this;
                }
                

                /// <param name="metadataBlob">Metadata that is designed to be handled by the game client. As an example, this may include properties as to how the item works, or other information you need to display. Metadata can also be stored as searchable [key value pairs](#metadata), and to individual [mod files](#get-modfiles).</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter MetadataBlob(string metadataBlob, Filtering condition = Filtering.None)
                {
                    Parameters[$"metadata_blob{condition.ClearText()}"] = metadataBlob;
                    return this;
                }

                /// <param name="metadataBlob">An ICollection of Metadata that is designed to be handled by the game client. As an example, this may include properties as to how the item works, or other information you need to display. Metadata can also be stored as searchable [key value pairs](#metadata), and to individual [mod files](#get-modfiles).</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter MetadataBlob(ICollection<string> metadataBlob, Filtering condition = Filtering.None)
                {
                    Parameters[$"metadata_blob{condition.ClearText()}"] = metadataBlob;
                    return this;
                }
                

                /// <param name="platformStatus">If the parent game has enabled per-platform files, by default only files which are approved and live for the [target platform](#targeting-a-platform) will be returned.<br/><br/>To request pending files, you can filter results by their current platform status, using `pending_only`, `approved_only`, `live_and_approved` or `live_and_pending`.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter PlatformStatus(string platformStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"platform_status{condition.ClearText()}"] = platformStatus;
                    return this;
                }

                /// <param name="platformStatus">An ICollection of If the parent game has enabled per-platform files, by default only files which are approved and live for the [target platform](#targeting-a-platform) will be returned.<br/><br/>To request pending files, you can filter results by their current platform status, using `pending_only`, `approved_only`, `live_and_approved` or `live_and_pending`.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetUserModfilesFilter PlatformStatus(ICollection<string> platformStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"platform_status{condition.ClearText()}"] = platformStatus;
                    return this;
                }
                
            }
#endregion
        
        }
    }
}
