// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using Modio.API.SchemaDefinitions;
using Modio.Errors;
using Modio.Extensions;

namespace Modio.API
{
    public static partial class ModioAPI
    {
        public static partial class Files
        {
            /// <summary>
            /// <p>Get all files that are published for the corresponding mod. Successful request will return an array of [Modfile Objects](#get-modfiles-2). We recommended reading the [filtering documentation](#filtering) to return only the records you want.</p>
            /// <p>__NOTE:__ If the [game](#edit-game) requires mod downloads to be initiated via the API, the `binary_url` returned will contain a verification hash. This hash must be supplied to get the modfile, and will expire after a certain period of time. Saving and reusing the `binary_url` won't work in this situation given it's dynamic nature.</p>
            /// </summary>
            /// <param name="filter">Filter to apply to the request.</param>
            /// <param name="modId">Mod id</param>
            internal static async Task<(Error error, JToken modfileObjects)> GetModfilesAsJToken(
                    long modId
,
            GetModfilesFilter filter
            ) {
                if (!IsInitialized()) return (new Error(ErrorCode.API_NOT_INITIALIZED), null);

                using var request = ModioAPIRequest.New($"/games/{{game-id}}/mods/{modId}/files", ModioAPIRequestMethod.Get, ModioAPIRequestContentType.FormUrlEncoded);


                return await _apiInterface.GetJson(request);
            }

            /// <summary>
            /// <p>Get all files that are published for the corresponding mod. Successful request will return an array of [Modfile Objects](#get-modfiles-2). We recommended reading the [filtering documentation](#filtering) to return only the records you want.</p>
            /// <p>__NOTE:__ If the [game](#edit-game) requires mod downloads to be initiated via the API, the `binary_url` returned will contain a verification hash. This hash must be supplied to get the modfile, and will expire after a certain period of time. Saving and reusing the `binary_url` won't work in this situation given it's dynamic nature.</p>
            /// </summary>
            /// <param name="filter">Filter to apply to the request.</param>
            internal static async Task<(Error error, Pagination<ModfileObject[]>? modfileObjects)> GetModfiles(
long modId
,
            GetModfilesFilter filter
            ) {
                if (!IsInitialized()) return (new Error(ErrorCode.API_NOT_INITIALIZED), null);

                using var request = ModioAPIRequest.New($"/games/{{game-id}}/mods/{modId}/files", ModioAPIRequestMethod.Get, ModioAPIRequestContentType.FormUrlEncoded);

                request.Options.AddFilterParameters(filter);

                return await _apiInterface.GetJson<Pagination<ModfileObject[]>>(request);
            }
#region Filter
        
            /// <summary>Constructs a filter built for this request type.</summary>
            /// <param name="pageIndex">The search will skip <c>pageIndex * pageSize</c> results and return (up to) the following <see cref="pageSize"/> results.</param>
            /// <param name="pageSize">Limit the number of results returned (100 max).<p>Use <see cref="SetPageIndex"/> to skip results and return later results.</p></param>
            public static GetModfilesFilter FilterGetModfiles(
                int pageIndex = 0,
                int pageSize = 100
            ) 
            => new GetModfilesFilter(
                pageIndex, 
                pageSize
            );
            
            /// <summary>
            /// Filter for GetModfiles, see <see cref="Files.FilterGetModfiles"/>
            /// to construct this filter <br/>
            /// Filtering options:<br/>
            /// </summary>
            public class GetModfilesFilter : SearchFilter<GetModfilesFilter>
            {
                internal GetModfilesFilter(
                    int pageIndex,
                    int pageSize
                ) : base(pageIndex, pageSize) 
                {
                }

                /// <param name="id">Unique id of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Id(long id, Filtering condition = Filtering.None)
                {
                    Parameters[$"id{condition.ClearText()}"] = id;
                    return this;
                }

                /// <param name="id">An ICollection of Unique id of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Id(ICollection<long> id, Filtering condition = Filtering.None)
                {
                    Parameters[$"id{condition.ClearText()}"] = id;
                    return this;
                }
                

                /// <param name="modId">Unique id of the mod.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter ModId(long modId, Filtering condition = Filtering.None)
                {
                    Parameters[$"mod_id{condition.ClearText()}"] = modId;
                    return this;
                }

                /// <param name="modId">An ICollection of Unique id of the mod.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter ModId(ICollection<long> modId, Filtering condition = Filtering.None)
                {
                    Parameters[$"mod_id{condition.ClearText()}"] = modId;
                    return this;
                }
                

                /// <param name="dateAdded">Unix timestamp of date file was added.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter DateAdded(long dateAdded, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_added{condition.ClearText()}"] = dateAdded.RoundTimestampToHour();
                    return this;
                }

                /// <param name="dateAdded">An ICollection of Unix timestamp of date file was added.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter DateAdded(ICollection<long> dateAdded, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_added{condition.ClearText()}"] = dateAdded.RoundTimestampsToHour();
                    return this;
                }
                

                /// <param name="dateScanned">Unix timestamp of date file was virus scanned.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter DateScanned(long dateScanned, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_scanned{condition.ClearText()}"] = dateScanned.RoundTimestampToHour();
                    return this;
                }

                /// <param name="dateScanned">An ICollection of Unix timestamp of date file was virus scanned.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter DateScanned(ICollection<long> dateScanned, Filtering condition = Filtering.None)
                {
                    Parameters[$"date_scanned{condition.ClearText()}"] = dateScanned.RoundTimestampsToHour();
                    return this;
                }
                

                /// <param name="virusStatus">Current virus scan status of the file. For newly added files that have yet to be scanned this field will change frequently until a scan is complete:<br/><br/>__0__ = Not scanned<br/>__1__ = Scan complete<br/>__2__ = In progress<br/>__3__ = Too large to scan<br/>__4__ = File not found<br/>__5__ = Error Scanning</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter VirusStatus(long virusStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_status{condition.ClearText()}"] = virusStatus;
                    return this;
                }

                /// <param name="virusStatus">An ICollection of Current virus scan status of the file. For newly added files that have yet to be scanned this field will change frequently until a scan is complete:<br/><br/>__0__ = Not scanned<br/>__1__ = Scan complete<br/>__2__ = In progress<br/>__3__ = Too large to scan<br/>__4__ = File not found<br/>__5__ = Error Scanning</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter VirusStatus(ICollection<long> virusStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_status{condition.ClearText()}"] = virusStatus;
                    return this;
                }
                

                /// <param name="virusPositive">Was a virus detected:<br/><br/>__0__ = No threats detected<br/>__1__ = Flagged as malicious<br/>__2__ = Flagged as containing potentially harmful files (i.e. EXEs)</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter VirusPositive(long virusPositive, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_positive{condition.ClearText()}"] = virusPositive;
                    return this;
                }

                /// <param name="virusPositive">An ICollection of Was a virus detected:<br/><br/>__0__ = No threats detected<br/>__1__ = Flagged as malicious<br/>__2__ = Flagged as containing potentially harmful files (i.e. EXEs)</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter VirusPositive(ICollection<long> virusPositive, Filtering condition = Filtering.None)
                {
                    Parameters[$"virus_positive{condition.ClearText()}"] = virusPositive;
                    return this;
                }
                

                /// <param name="filesize">Size of the file in bytes.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Filesize(long filesize, Filtering condition = Filtering.None)
                {
                    Parameters[$"filesize{condition.ClearText()}"] = filesize;
                    return this;
                }

                /// <param name="filesize">An ICollection of Size of the file in bytes.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Filesize(ICollection<long> filesize, Filtering condition = Filtering.None)
                {
                    Parameters[$"filesize{condition.ClearText()}"] = filesize;
                    return this;
                }
                

                /// <param name="filehash">MD5 hash of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Filehash(string filehash, Filtering condition = Filtering.None)
                {
                    Parameters[$"filehash{condition.ClearText()}"] = filehash;
                    return this;
                }

                /// <param name="filehash">An ICollection of MD5 hash of the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Filehash(ICollection<string> filehash, Filtering condition = Filtering.None)
                {
                    Parameters[$"filehash{condition.ClearText()}"] = filehash;
                    return this;
                }
                

                /// <param name="filename">Filename including extension.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Filename(string filename, Filtering condition = Filtering.None)
                {
                    Parameters[$"filename{condition.ClearText()}"] = filename;
                    return this;
                }

                /// <param name="filename">An ICollection of Filename including extension.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Filename(ICollection<string> filename, Filtering condition = Filtering.None)
                {
                    Parameters[$"filename{condition.ClearText()}"] = filename;
                    return this;
                }
                

                /// <param name="version">Release version this file represents.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Version(string version, Filtering condition = Filtering.None)
                {
                    Parameters[$"version{condition.ClearText()}"] = version;
                    return this;
                }

                /// <param name="version">An ICollection of Release version this file represents.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Version(ICollection<string> version, Filtering condition = Filtering.None)
                {
                    Parameters[$"version{condition.ClearText()}"] = version;
                    return this;
                }
                

                /// <param name="changelog">Changelog for the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Changelog(string changelog, Filtering condition = Filtering.None)
                {
                    Parameters[$"changelog{condition.ClearText()}"] = changelog;
                    return this;
                }

                /// <param name="changelog">An ICollection of Changelog for the file.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter Changelog(ICollection<string> changelog, Filtering condition = Filtering.None)
                {
                    Parameters[$"changelog{condition.ClearText()}"] = changelog;
                    return this;
                }
                

                /// <param name="metadataBlob">Metadata that is designed to be handled by the game client and is recommended to not be exposed to content creators when submitting their modfiles. As an example, this may include properties such as what version of the game this file is compatible with.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter MetadataBlob(string metadataBlob, Filtering condition = Filtering.None)
                {
                    Parameters[$"metadata_blob{condition.ClearText()}"] = metadataBlob;
                    return this;
                }

                /// <param name="metadataBlob">An ICollection of Metadata that is designed to be handled by the game client and is recommended to not be exposed to content creators when submitting their modfiles. As an example, this may include properties such as what version of the game this file is compatible with.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter MetadataBlob(ICollection<string> metadataBlob, Filtering condition = Filtering.None)
                {
                    Parameters[$"metadata_blob{condition.ClearText()}"] = metadataBlob;
                    return this;
                }
                

                /// <param name="platformStatus">If the parent game has enabled per-platform files, by default only files which are approved and live for the [target platform](#targeting-a-platform) will be returned.<br/><br/>To QA pending files, you can filter results by their current platform status, using `pending_only`, `approved_only`, `live_and_approved` or `live_and_pending`. With the exception of `approved_only` and `live_and_approved` which is available to everyone, all other values are restricted to game administrators.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter PlatformStatus(string platformStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"platform_status{condition.ClearText()}"] = platformStatus;
                    return this;
                }

                /// <param name="platformStatus">An ICollection of If the parent game has enabled per-platform files, by default only files which are approved and live for the [target platform](#targeting-a-platform) will be returned.<br/><br/>To QA pending files, you can filter results by their current platform status, using `pending_only`, `approved_only`, `live_and_approved` or `live_and_pending`. With the exception of `approved_only` and `live_and_approved` which is available to everyone, all other values are restricted to game administrators.</param>
                /// <param name="condition"><see cref="Filtering"/></param>
                public GetModfilesFilter PlatformStatus(ICollection<string> platformStatus, Filtering condition = Filtering.None)
                {
                    Parameters[$"platform_status{condition.ClearText()}"] = platformStatus;
                    return this;
                }
                
            }
#endregion
        
        }
    }
}
